\chapter*{Introduction}
\addtotoc{Introduction}
%For years, processor manufacturers have delivered increases in clock rates. While manufacturing technology still improves, physical limitations of semiconductor-based electronics have become a major concern of design. In order for the processors to continue to improve in performance, multi-core design has become necessary. However, increasing the number of processor cores does not provide automatic benefits for legacy applications. Parallelisation of the performance-demanding parts of an application is difficult because computation concurrency management are mixed within the application code. 
%, which includes ensuring the correct sequencing of the interactions between different computational executions, and coordinating access to resources that are shared among executions. 
%One approach to address this issue is to present the application as a collection of independent components and specify their communication in a so-called coordination language, thus separating the concerns of computation, coordination and concurrency management.
%
%ak is motivated by KPNs
The concepts of the new coordination language \ak\ are described in \cite{astrakahn}. The language defines the coordination behaviour of asynchronous stateless components (\emph{boxes}) and their orderly interconnection via stream-carrying channels with finite capacity. \ak\ structures the interconnect using a fixed set of wiring primitives, viz. serial and parallel composition, wrap-around connection and serial replication. Boxes are connected to the network with one or two input channels and one or more output channels. A stateless box does not synchronise data on its input channels; to this end, \ak\ provides a synchronisation facility called \emph{synchroniser}. In order to deal with the issue of application progress, \ak\ attempts to provide an automatic resource and concurrency management based on communication demand.

%Concurrency regulation assumes that several copies of a box may run in parallel, thus \ak\ requires boxes to have no state.
%\ak\ is motivated by Kahn process networks, which is a theoretical model (for what?) where processes communicate via unbounded FIFO channels. However, in real-world applications, a large number of concurrent processes and their communication facilities share a very limited amount of resources.


    \section*{Motivation and Contribution}
\addtotoc{Motivation and Contribution}
At the moment, the \ak\ project is at an early stage and there exists no software implementation at all. In order to carry out research towards automatic resource and concurrency management, an execution environment for \ak\ applications must be developed. In brief, such an environment includes a compiler to generate an intermediate representation of the application source code and a runtime system to interprete the representation under the input data. The main concepts of \ak\ have to be well-established for the execution environment to be implemented.

This thesis focuses on the implementation of synchronisers and their role in the serial replication wiring pattern. Synchronisers are programmed in a dedicated language that is described in \cite{astrakahn}. We provide some minor syntax improvements and detailed explanation how each language construct should be used. An \ak\ synchroniser has a non-deterministic behaviour. We give an execution algorithm that defines the ordering of non-deterministic choices made by the synchroniser, and which is a basis for the synchroniser runtime. We implement the language compiler that generates the data structure to be interpreted by the runtime and the communication passport of the synchroniser. The compiler performs some semantic and type checking and reports source code errors.

In \ak\ the output from the serial replication pipeline is defined using the concept of fixed point. A fixed point is a message that is not changed by being processed by a newly created replica. In order to detect fixed point messages, the \ak\ runtime has to be provided with a pattern that matches all of them. We show how this pattern can be embedded into the operand network of the serial replication combinator, so that the programmer does not have to specify it explicitly within the \ak\ application code. Since the original approach to the output from the serial replication is quite complicated, we provide a simple alternative. In order to suppress the growth of the replica chain, \ak\ introduces a reverse fixed point, which is a state of a replica that is known to act as a bypass from some time onwards. We give formal definitions of both kinds of fixed point and provide algoritms for the \ak\ compiler to detect them.


    \section*{Outline}
The remainder of the thesis is as follows. Chapter \ref{chap_found} introduces \ak\ and presents some theoretical background in coordination programing and stream processing. \ak\ is compared with a recent component system example from either field.

In Chapter \ref{chap_impl} the implementation of the synchroniser is described in detail. We describe a synchroniser mathematically in order to define its behaviour more precisely. The chapter focuses on the language guide, the execution algorithm and the implementation of the compiler.

In Chapter \ref{chap_sr} the machinery behind the serial replication in \ak\ and the role of synchronisers in it is explained.

Chapter \ref{concl} concludes the thesis, providing directions for further research.
