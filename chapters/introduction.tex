\chapter{Introduction}
For years, processor manufacturers have delivered increases in clock rates. While manufacturing technology still improves, physical limitations of semiconductor-based electronics have become a major concern of design. In order for the processors to continue to improve in performance, multi-core design has become necessary. However, increasing the number of processor cores does not provide automatic benefits for legacy applications. Parallelisation of the performance-demanding parts of an application is difficult because computation concurrency management are mixed within the application code. 
%, which includes ensuring the correct sequencing of the interactions between different computational executions, and coordinating access to resources that are shared among executions. 
One approach to address this issue is to present the application as a collection of independent components and specify their communication in a so-called coordination language, thus separating the concerns of computation, coordination and concurrency management.

%ak is motivated by KPNs
The concepts of the new coordination language \ak\ are described in \cite{astrakahn}. The language defines the coordination behaviour of asynchronous stateless components (\emph{boxes}) and their orderly interconnection via stream-carrying channels with finite capacity. \ak\ structures the interconnection using a fixed set of wiring primitives, wiz. serial and parallel composition, wrap-around connection and serial replication. Boxes are connected to the network with one or two input channels and one or more output channels. A stateless box does not synchronise data on its input and output channels; to this end, \ak\ provides a synchronisation facility called \emph{synchroniser}. In order to deal with the issue of application progress, \ak\ attempts to provide an automatic resource and concurrency management based on communication demand.

%Concurrency regulation assumes that several copies of a box may run in parallel, thus \ak\ requires boxes to have no state.
%\ak\ is motivated by Kahn process networks, which is a theoretical model (for what?) where processes communicate via unbounded FIFO channels. However, in real-world applications, a large number of concurrent processes and their communication facilities share a very limited amount of resources.


    \section{Motivation and Contribution}
At the moment, the \ak\ project is on the initial stage and there exists no software implementation at all. In order to carry out research towards automatic resource and concurrency management, an execution environment for \ak\ applications must be developed. In brief, such an environment includes a compiler to generate an intermediate representation of the application source code and a runtime system to interprete the representation under the input data. Before the execution environment can be implemented, the main concepts of \ak\ must be well-established.

This thesis focuses on the implementation of synchronisers and their role in the serial replication wiring pattern. Synchronisers are programmed in a dedicated language that is described in \cite{astrakahn}. We provide some minor syntax improvements and explain how each language construct should be used in a detailed guide. An \ak\ synchroniser has non-deterministic behaviour. We give an execution algorithm which defines the ordering of non-deterministic choices made by the synchroniser, and is a basis for the synchroniser runtime. We implement the synchroniser language compiler that generates the data structure to be interpreted by the runtime. The compiler performs some semantic and type checking and reports errors in the source code.



CAL passport generation


role of synch-s in serial replication defined by fixed point
We show that how the output condition can be present in the operand network
We show the growth of the replica chain can be suppressed defining a reverse fixed point
and provide etection algoritms for both types
however the approach is too complex, we describe the more simple yet functional alternative


    \section{Outline}



