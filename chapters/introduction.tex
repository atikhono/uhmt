\chapter{Introduction}
For years, processor manufacturers have delivered increases in clock rates. While manufacturing technology still improves, physical limitations of semiconductor-based electronics have become a major concern of design. In order for the processors to continue to improve in performance, multi-core design has become necessary.

Unlike the increase in clock frequency, increasing the number of processor cores does not provide automatic benefits for conventional programs. Parallel programming in the conventional style is difficult because computation is mixed with concurrency management, which includes ensuring the correct sequencing of the interactions between different computational executions, and coordinating access to resources that are shared among executions. One of the approaches that addresses the issue of mixed computation and coordination is to separate these concerns. The approach requires explicit parallelisation of an application and specification of component communication in so-called coordination language.

%ak is motivated by KPNs
The concept of a new coordination language \ak\ is described in \cite{astrakahn}. The language defines the coordination behaviour of asynchronous components (boxes) and their orderly interconnection via stream-carrying channels. The \ak\ computation model is based on Kahn process networks, where processes communicate via unbounded FIFO channels. However, in real-world applications, a large number of concurrent processes and their communication facilities share a very limited amount of resources. In order to deal with the issue of application progress, \ak\ attempts to provide a self-regulatory concurrency mechanism based on the concept of communication pressure. Concurrency regulation supposes that several copies of a box may run in parallel, thus \ak\ requires boxes to keep no state. A stateless box knows nothing about synchronisation, therefore data must be synchronised before they are sent to a box. \ak\ provides a synchronisation facility -- a synchroniser -- that is able to store received data and retrieve them for the sole purpose of sending them on, either as they are, or combined with other stored or received data and with trivial data extensions computed by the synchroniser itself.
% ak achieves separation of coordination and synchronisation concerns as well

Boxes are connected to the streaming network with one or two input channels and one or more output channels. Synchronisers may have many input channels. Streaming networks in \ak\ are expressed with four wiring patterns, namely serial and parallel composition, wrap-around connection and serial replication.


    \section{Motivation}
%write about the state of the project. the runtime system needs to be developed before the regulation research.
%The \ak\ project is now in its initial state and there is yet no implementation. The playground environment need to be developed for the research towards the self-regulation.

%The aim of this thesis is to identify the role of the synchroniser analysis in the project. It includes implementation of the \ak\ synchroniser and integration of the implementation into the runtime system prototype. The output form the infinite replication relies on the synchroniser analysis.

%explain about pressure propagation and statistics
%The long-term goal of the \ak\ project is to provide an environment for development of scalable concurrent applications that do not require manual tuning efforts. Though the adaptive self-regulation mechanism is not known to propose something for synchronisers, we try to review the possible strategies for the pressure propagation through synchroniser.


%An Astra\emph{Kahn} approach to adaptive concurrency relies on the concept of communication pressure propagation across a network. Since pressure propagation directly affects proliferation levels of certain vertices, effectiveness of concurrency self-regulation depends largely on correctness of pressure propagation strategy. An important part of this strategy is pressure propagation through synchronisers because, unlike other vertices in Astra\emph{Kahn}, they induce negative pressure that represents a demand for messages in a certain part of a network.

%This project is focused on synchroniser analysis and development of supporting tools. Since the synchroniser is programmed in a dedicated language, a compiler for this language is needed. Target architecture assembly generation is of no concern within the project, thus, the compiler translates a given source code into a C program and then calls available C compiler to generate an executable file. Also, the compiler provides various syntactic and semantic checks.

%In order to propagate pressure through a synchroniser, Astra\emph{Kahn} coordinator needs to know its \emph{transfer function}. The transfer function describes relations between demands of messages on a synchroniser's input and output channels. Derivation of the transfer function is a concern of static analysis, in particular, execution path analysis. Because synchronisers are non-deterministic, there may be potentially an infinite number of possible execution paths and therefore more than one transfer function. It may be impossible to determine an exact execution path at compile time, because it may depend on incoming message content. If synchroniser has an inner loop, the transfer function must consider the number of iterations in this loop. Thus, transfer function derivation relates to induction variable analysis.

%These issues are subject to synchroniser analysis in the project. Once a set of transfer functions is obtained, it is up to TPL how to choose a particular transfer function and propagate pressure through a synchroniser. Also, synchroniser analysis includes passport generation for Constraint Aggregation Layer.


    \section{Contribution}
%The contribution of the research is a technique for pressure propagation through synchronisers. This mechanism is an important part of concurrency self-regulating mechanism in Astra\emph{Kahn}. An approach to the problem will be provided in accordance with runtime system regulation policies and a tool for pressure propagation support on runtime will be implemented. The chosen pressure propagation strategy will be tested with a runtime system prototype to decide on its usability for adaptive concurrency regulation. Depending on the result, synchronisation model nondeterminism restrictions and/or strategy changes can be provided to enable efficient concurrency self-regulation on runtime.


    \section{Outline}



