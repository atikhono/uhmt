\chapter{Introduction}
%\addtotoc{Introduction}
%For years, processor manufacturers have delivered increases in clock rates. While manufacturing technology still improves, physical limitations of semiconductor-based electronics have become a major concern of design. In order for the processors to continue to improve in performance, multi-core design has become necessary. However, increasing the number of processor cores does not provide automatic benefits for legacy applications. Parallelisation of the performance-demanding parts of an application is difficult because computation concurrency management are mixed within the application code. 
%, which includes ensuring the correct sequencing of the interactions between different computational executions, and coordinating access to resources that are shared among executions. 
%One approach to address this issue is to present the application as a collection of independent components and specify their communication in a so-called coordination language, thus separating the concerns of computation, coordination and concurrency management.
%
%ak is motivated by KPNs
The concepts of the new coordination language \ak\ are described in \cite{astrakahn}. The language defines the coordination behaviour of asynchronous stateless components (\emph{boxes}) and their orderly interconnection via stream-carrying channels with finite capacity. \ak\ structures the interconnect using a fixed set of wiring primitives, viz. serial and parallel composition, wrap-around connection and serial replication. Boxes are connected to the network with one or two input channels and one or more output channels. A stateless box does not synchronise data on its input channels; to this end, \ak\ provides a synchronisation facility called \emph{synchroniser}. \added{Synchronisers are finite state machines for joining messages and sending them on to the output channels. A synchroniser is connected to the network with one or more input and output channels. \ak\ provides a dedicated language to define synchronisers, while boxes are specified in any conventional programming language.} In order to deal with the issue of application progress, \ak\ attempts to provide an automatic resource and concurrency management based on communication demand.

%Concurrency regulation assumes that several copies of a box may run in parallel, thus \ak\ requires boxes to have no state.
%\ak\ is motivated by Kahn process networks, which is a theoretical model (for what?) where processes communicate via unbounded FIFO channels. However, in real-world applications, a large number of concurrent processes and their communication facilities share a very limited amount of resources.


    \section{Motivation}
%\addtotoc{Motivation and Contribution}
At the moment\added{ the work on this thesis started}, the \ak\ project was at an early stage and there existed no software implementation\deleted{ at all}. In order to carry out research towards automatic resource and concurrency management, an execution environment for \ak\ applications must be developed. In brief, such an environment includes a compiler to generate an intermediate representation of the application source code and a runtime system to interpret the representation under the input data.\added{ Since \ak\ provides the coordination language and the programming language of synchronisers, the two compilers for them are needed. The grammar of the synchroniser language is given in \cite{astrakahn}. The aim of this work is to study synchronisers and implement the synchroniser language compiler.}

\added{An \ak\ component, either a box or a synchroniser, is both a consumer and a producer for some other components in the network. The static correctness of a connection demands that the statically guaranteed properties of an output message be sufficient to satisfy the static requirements of its recipients. In order to check the static correctness over the network, a component can be abstracted with respect to its data-transformation behaviour as a so-called communication passport $p \Rightarrow P$, where $p$ is the conjunction of all the requirements and $P$ is the conjunction of all the guarantees. Since boxes are not analysable by \ak\, the programmer has to specify passports for them. Synchronisers are fully analysable by \ak\ and their passports can be extracted from the source code exclusively by program analysis. Such an analysis can be implemented as a part of the synchroniser compiler.}

\added{\ak\ provides the serial replication combinator, which creates a conceptually infinite number of copies of its operand network and connects them in a serial fashion. In \ak\ the output from the serial replication pipeline is defined using the concept of forward fixed point. A forward fixed point is a message that is not changed by being processed by a newly created replica. In order to detect fixed point messages, the \ak\ runtime system has to be provided with a pattern that matches all of them. The language report \cite{astrakahn} gives an intuitive explanation of how the matching pattern can be embedded into the operand network of the serial replication combinator using synchronisers, so that the programmer does not have to specify it explicitly within the \ak\ application code. The pattern can be extracted from the source code of those synchronisers by program analysis.}

\added{In order to suppress the growth of the replica chain in the serial replication network, \ak\ introduces a so-called reverse fixed point mechanism. A reverse fixed point on a channel is a state of a replica, in which it transmits messages from that channel unchanged. Once the \ak\ runtime system detects that a replica is in the reverse fixed point state on some channel, the connection on that channel can be optimised by removing the replica. Since synchronisers are the only stateful components in \ak\ , a state of a replica, and thus a reverse fixed point, is formed by the states of its synchronisers. The reverse fixed point can be extracted by program analysis from the source code of the replicas synchronisers.}


    \section{Contribution}
This thesis focuses on the implementation of synchronisers and their role in the serial replication wiring pattern. We provide some minor syntax improvements and detailed explanation how each language construct should be used. An \ak\ synchroniser has a non-deterministic behaviour. We give an execution algorithm that defines the ordering of non-deterministic choices made by the synchroniser, and which is a basis for the synchroniser runtime. We implement the language compiler that generates the data structure to be interpreted by the runtime and the communication passport of the synchroniser. The compiler performs semantic and type checking and reports source code errors.

\added{The language report \cite{astrakahn} explains the machinery behind the serial replication briefly. The serial replication is an important part of \ak\ and it has to be well-established for the execution environment to be implemented. We analyse the original synchroniser-based approach to fixed points and show how it can be implemented. As a part of the analysis, we give the topological properties of the operand network that are required for the existence of forward and reverse fixed points. The analysis shows that the construction and the debugging of an operand network with a complex fixed point condition can be quite complicated. In order to avoid having to construct complicated operand networks, we provide a simple alternative solution for forward fixed point. Finally, we provide algorithms for the \ak\ compiler to detect both kinds of fixed point in the operand network.}


    \section{Outline}
The remainder of the thesis is as follows. Chapter \ref{chap_found} introduces \ak\ and presents some theoretical background in coordination programing and stream processing. \ak\ is compared with a recent component system example from either field.

In Chapter \ref{chap_impl} the implementation of the synchroniser is described in detail. We describe a synchroniser mathematically in order to define its behaviour more precisely. The chapter focuses on the language guide, the execution algorithm and the implementation of the compiler.

In Chapter \ref{chap_sr} the machinery behind the serial replication in \ak\ and the role of synchronisers in it is explained.

Chapter \ref{concl} concludes the thesis, providing directions for further research.
