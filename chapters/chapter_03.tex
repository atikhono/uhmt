% TODO change this uglyness
\chapter{The Serial Replication in \ak\ }
%The serial replication combinator implements recursive computations and the loop construct with pipeline parallelism.
In this chapter we explain the machinery behind the serial replication in \ak\ and the role of synchronisers in it. We introduce the concept of the forward fixed point for the replication pipeline and show how it is used to organise the output from the infinite chain of replicas. In order to supress the growth of the replicas chain, we present the concept of the reverse fixed point and show how it is used to optimise some replicas in the head of the chain.


%TODO
%First of all, the semantics of AstraKahn on the TPL is described in terms of structures put in place for the coordinator, i.e. a controlling agent, or indeed a group of agents, responsible for progress and communication of the KPN vertices.
%


    \section{\ak\ Approach to the Serial Replication}
The serial replication combinator creates conceptually infinite number of copies of its operand network, and connects them in a chain. Replication is demand-driven, hence replicas are created dynamically in runtime. A fresh replica is \emph{inactive}\footnote{More generally, we call a replica inactive when all of its synchronisers are in their start states, none of its channels has messages in them and no box is running}, hence it does not necessarily require significant resouces since \ak\ boxes are stateless and synchronisers require no resouces in their start state\footnote{When a synchroniser transitions back to the start state, it flushes its store variables}. Indeed the cost of replication is only felt when the replicas are active, which is the case when the first message is received until all messages have left the replica and all its synchronisers have returned to their start states.

In S-Net, the output from the replication pipeline is based on the record subtyping in the type system. The replication combinators in S-Net require the programmer to specify a termination pattern, so that each record that is a subtype of this pattern leaves the replication pipeline throught the output stream.

In \ak\, the output from the replication pipeline is inspired by the concept of a fixed point. From the mathematical point of view a fixed point of a function is an element of the function's domain the function maps to itself. That is to say, the function $f(x): X \to Y$ has a fixed point in $x_0 \in X$ iff $f(x_0) = x_0$. The definition yields an important termination consideration
\begin{equation}
\exists n: \; \forall k<n \;\; f^{(k)}(x) \neq f^{(n)}(x) \; \land \; \forall k \ge n \;\; f^{(k)}(x) = f^{(n)}(x) \nonumber
\end{equation}
when the function $f$ is computed recursively\footnote{$f^{(n)}(x)$ denotes $\underbrace{f(f(\dots f}_n (x) \dots))$}. The serial replication combinator implements such a computation as shown in Fig. \ref{fig:fp}. After the $n$-th replica has processed the message $f^{(n-1)}(x) \neq x_0$ the computation reaches the fixed point $x_0$, and the message $x_0$ is sent on to the output channel of the serial replication network $f^{*}$.
\begin{figure}[h!]
\centering
\includegraphics[scale=0.8]{figs/chapter_03_fp.pdf}
\caption{The recursive computation in \ak\ }
\label{fig:fp}
\end{figure}

The number of iterations $n$ needed to reach the fixed point is not known in advance, meaning that in order to utilize the fixed point as shown in Fig. \ref{fig:fp}, \ak\ must be able to detect the fixed point message right at the time it is produced by the $(n-1)$-th replica. Therefore, just like in S-Net, \ak\ needs to be provided with a pattern that matches all the fixed point messages of the operand network. In S-Net, the serial replication combinator requires to specify the pattern as one of its operands, while in \ak\ the pattern can be encoded within the operand network due to the ability of synchronisers to check the message content and perform different actions depending on the result of the check. The pattern is extracted from the operand network due to the fact \ak\ can analyse synchronisers.
%Due to separation of concerns \ak\ does not have to analyse the box code\footnote{except for CAL passport generation}, therefore the fixed point must be defined in synchronisers or the network topology of a net.

The chain of replicas grows as the computation progresses, however, in the example in Fig. \ref{fig:fp} the computation is carried out only by a single replica in the tail of the chain. The replicas in the head of the chain have processed the message and are not used anymore. In order to suppress the growth of the chain, \ak\ is committed to detect such replicas and optimise the connection by removing them. Since \ak\ boxes are stateless, an operand network can have a state that is fully defined by the states of its synchronisers. A replica of the operand network can be removed from the chain safely iff the replica is in a state, in which it transmits any message without change, i.e. any message it receives is a fixed point. We will call such a state of the replica the reverse fixed point state.

In the remainder of the chapter we give formal definitions for a fixed point message and reverse fixed point state and provide algorithms for the \ak\ compiler to detect them. Consequently we will call the fixed point message the forward fixed point.
%The intention of the forward fixed point is to cut an infinite tail of replicas chain. The reverse fixed point is an optimisation of an input connection that suppresses the growth of the replicas chain. 


    \section{Forward Fixed Point}
%We will now explain how the pattern to match the fixed point messages can be encoded within the operand network.
Once the computation in the serial replication network has reached the fixed point, newly created replicas are known to transmit the fixed point messages without change. \ak\ does not analyse boxes\footnote{Except for the CAL passport generation}, so it can conclude about the operand network behaviour only from its synchronisers. Thus, in order for the operand network to be analysable by \ak\ for the required behaviour, it must contain a path that does not traverse boxes and may traverse synchronisers. Because a newly created replica is inactive and hence the synchronisers in it are in their start states, the start states of the synchronisers that belong to the path must have a special transition that would implement sending of the message on to the next synchroniser along the path. Since transitions can be conditional on the message content, the fixed point pattern, or rather the fixed point condition, can be encoded in these special transitions.

%1) synchronisers approach (only detects integer fields like S-Net)
The existence of a forward fixed point requires the operand network to have some topological properties that are formally defined as follows. Consider a network $N$ that has an input and an output channel, both named $x$.

\begin{definition}The network $N$ is said to have a forward fixed point in $x$ if and only if the following requirements are satisfied:
\begin{enumerate}
\item There exists a condition $P(m)$ on the content of the message $m$ received by the network on the input channel $x$ under which it follows a unique non-branching path to the output channel $x$ without traversing any boxes
\item The path can traverse synchronisers, but then whenever $P(m)$ is true and the synchroniser is in the start state, it must accept $m$ and transition back to the start state while sending the message $m$ on the path unchanged and without producing any other output%TODO fix
\end{enumerate}
\end{definition}

% Give a definition for "edge that satisfies the fixed-point definition"
The condition $P$ may not be unique for each network, and when it is not, the fixed point condition of the network is a disjunction of all such conditions. The condition can also be a tautology, in which case the forward fixed point is called unconditional. When the path traverses a single synchroniser, the fixed point condition is defined exclusively by the synchroniser transitions that loop around the start state and send on the accepted messages unchanged. When the path traverses several synchronisers, the fixed point condition of the network is a conjunction of the fixed point conditions of these synchronisers. We demonstrate the construction of the fixed point condition with the example operand network $N$ pictured in Fig. \ref{fig:ffp}.

\begin{figure}[h!]
\centering
\includegraphics[scale=0.8]{figs/chapter_04_ffp.pdf}
\caption{Forming of the forward fixed point condition of a network}
\label{fig:ffp}
\end{figure}

Apart from all the paths that traverse boxes, the operand network $N$ has a unique path $[s_1, \: s_2, \: s_3]$ that traverses only synchronisers. The synchroniser $s_2$ has two transitions that loop around the start state and send on messages they accept unchanged with the firing conditions $p^{1}_2(m)$ and $p^{1}_2(m)$. A message $m$ is a fixed point for the network $N$ when it satisties any of these conditions, i.e. $p^{1}_2(m) \lor p^{1}_2(m)$. The synchronisers $s_1$ and $s_3$ have fixed point conditions $p_1(m)$ and $p_3(m)$ respectively, where $p_i(m) = p^{1}_i(m) \lor \dots p^{j}_i$, $i=1,3$ and $j$ is the number of transitions in each synchroniser that loop around the start state and send on messages unchanged. Then the fixed point condition of the network $N$ is $p_1(m) \land (p^{1}_2(m) \lor p^{1}_2(m)) \land p_3(m)$.


    \subsubsection{Output from the Serial Replication Network}
Now we will clarify how the serial replication network is wired to the rest of the \ak\ application network and how the output is produced.

Strictly speaking, the serial replication is not just a wiring pattern since it does not simply wire the replicas of its operand network. It also creates a set of output channels and augments the replicas with some auxiliary synchronisers.
%However, in the main it wires the replicas in a serian fashion and we will consequently call the FPS a connection.

%We denote the FPS connection as $A^{*} = A' \: .. \: A' \: .. \: A' \: .. \: \dots$, where $A'$ is the network that contains $A$ and provides additional wiring to ensure that all output channels of $A'$ match its input channels bijectively.

The serial replication $N^{*}$ defines the output channel set $\mathcal{N}_{out}$ as follows:
\begin{equation}
\mathcal{N}_{out} = \{ name(c) \: | \: c \in \mathcal{O} \land fp(c) \}\nonumber
\end{equation}
where $\mathcal{O}$ is the output channel set of $N$ and the predicate $fp(c)$ is true on any channel $c$ that has a forward fixed point. The serial replication creates a set of fresh output channels $\mathcal{O}^{*}$ taking the names from the set $\mathcal{N}_{out}$. A message that comes to an inactive replica on any channel $c$ with $name(c) \in \mathcal{N}_{out}$ and satisfies the fixed point condition on that channel is immediately transferred to the identically named output channel from $\mathcal{O}^{*}$. A network in Fig. \ref{fig:ffp_out} demonstrates how the output is produced from the serial replication of a network that has a single input and a single output channel.

\begin{figure}[h!]
\centering
\includegraphics[scale=0.8]{figs/chapter_04_ffp_out.pdf}
\caption{Output from the serial replication network}
\label{fig:ffp_out}
\end{figure}

The operand network $N$ has the fixed point condition $P$. A synchroniser $S^{(i)}$ is inserted in front of every inactive replica $N^{(i+1)}$ to check whether a message $m$ in channel $x^{(i)}$ satisfies the condition $p$. If $P(m)$ is true, the synchroniser sends the message $m$ to the output channel $x$ of $N^{*}$. Otherwise, it is sent to the input channel $x^{(i+1)}$ of the next replica of $N$. The listing of the synchroniser $S^{(i)}$ is given in Fig. \ref{ffp:synch_filt}.

\textbf{TODO urgent! Fix to a net of synchronisers in case there are more than one fixed point conditions on a message}
\begin{figure}[h!]
\begin{lstlisting}[frame=single,mathescape]
synch $S^{(i)}$ ($x^{(i)}$ | $x^{(i+1)}$, $x$)
{
  start {
    on:
      $x^{(i)}$.$P$ {
        send this => $x$;
      }
      $x$.else {
        send this => $x^{(i+1)}$;
      }
  }
}
\end{lstlisting}
\caption{The synchroniser $S^{(i)}$}
\label{ffp:synch_filt}
\end{figure}

The merger $M$ accepts input messages from all synchronisers $S^{(i)}$ in the serial replication network and resends the messages to the output channel $x$ of $N^{*}$.

%An FPS is a form of replication wiring whereby an infinite chain of replicas is created, connected in series. The connection is denoted as A* for any operand network A and can be thought of as the equivalent of $A^{*} = A'..A'..A'.. \dots$ where $A'$, called the streamlining of the vertex A, is a network that contains A and provides some additional wiring to ensure that each output channel of A? matches an input channel and vice versa. We will dwell on the streamlining procedure a little further down, and at this point only remark that if all output channels of A match its input channels bijectively, A' = A.

    \subsection{Forward Fixed Point Detection}
    \subsubsection{Extracting of the fixed point condition from a synchroniser}
The existence of a forward fixed point requires the synchronisers of the operand network that define the fixed point condition to have at least one transition in their start states that accepts the fixed point messages and send them on unchanged and without producing any other output. Coded in the synchroniser language, the transition that defines the fixed point condition $p$ in channel $x$ is presented in \ref{ffp:synch_fp}.

\begin{figure}[h!]
\begin{lstlisting}[frame=single,mathescape]
start {
  on:
    x.$p$ {
      send this => x;
    }
  ...
}
\end{lstlisting}
\caption{The start state of a synchroniser that encodes the fixed point condition $p$}
\label{ffp:synch_fp}
\end{figure}

We shall note, that there exists no more transition from the start state with the same structure (a single \emph{send} clause). Otherwise, the synchroniser has the fixed point condition that is a disjunction of conditions in such transitions. The algorithm in Fig. \ref{fig:ffp_extract} checks is a forward fixed point exists in channel $x$ and extracts the fixed point condition from the synchroniser source code. The algorithm assumes that channel $x$ is declared as an input and an output channel of the synchroniser.

\begin{figure}[h!]
\noindent\fbox{%
\begin{minipage}{\dimexpr\linewidth-2\fboxsep-2\fboxrule\relax}
\begin{algorithmic}[1]
\Function{extract\_ffp}{$code, x$}
  \State $synch\gets parse$($code$)\Comment{\emph{parses the source code and returns the abstract syntax tree}}

  \State $state\gets get\_state\_by\_name$(\tangled{start})\Comment{\emph{get the start state tree from the state list}}

  \State $CondList\gets nil$

  \For{\textbf{each} \emph{trans in trans\_list}($state$)}
    \If{$get\_port$($trans$) $\neq$ \tangled{x}}
      \State \textbf{continue}\Comment{the transition reads from another channel}
    \EndIf
    \If{$get\_goto$($trans$) $\neq$ (\tangled{start} $\lor$ $\emptyset$)}
      \State \textbf{continue}\Comment{\emph{the transition does not loop around the state state}}
    \EndIf
    \If{$get\_assign$($trans$) $\neq$ $\emptyset$}
      \State \textbf{continue}
    \EndIf
    
    \State $send\gets get\_send$($trans$)
    \If{$get\_port$($send$) $\neq$ \tangled{x}}
      \State \textbf{continue}\Comment{\emph{messages are sent to another channel}}
    \EndIf 
    \If{$get\_msg$($send$) $\neq$ $this$}
      \State \textbf{continue}
    \EndIf

    \State $cond\gets get\_condition$($trans$)
    \If{$cond$ \emph{is not CondDataMsg}}
      \State \textbf{continue}\Comment{\emph{the condition cannot be a segmentation mark or an} \texttt{.else}}
    \EndIf
    \If{$cond \notin CondList$}
      \State $CondList\gets CondList$ \texttt{..} $cond$
    \EndIf

  \EndFor

  \If{$CondList = nil$}
    \State \emph{error}
  \EndIf
  \State \textbf{return} $CondList$
\EndFunction
\end{algorithmic}
\end{minipage}%
}
\caption{Extracting the fixed point condition from a synchroniser\label{fig:ffp_extract}}
\end{figure}


    \subsubsection{Path Search}
%Algorithm that uses extract_ffp, returns the list of all atomic FP conditions for the fixed point message





2) wire-through (applicable to detect non-integer fixed points, for iterative computation with the floating-point presicion)




%%%% IMPLEMENTATION NOTES
%%%%
In \ak\, a message leaves the replication pipeline exclusively via a special complement channel that is wired to the rest of the \ak\ network. The programmer has to make sure that the messages to be sent on are detected within the operand network and sent to this channel. 

Thus, the serial replication in \ak\ enforces a topological property of the operand network that is formally defined as follows. Consider the serial replication $N^{*}$ of an operand network $N$ with the input and output channel sets $\mathcal{I}$ and $\mathcal{O}$ respectively. Consequently, the set of matched inputs and outputs is $\mathcal{M}(\mathcal{I}, \: \mathcal{O}) = \mathcal{I} \cap \mathcal{O}$. In order for the serial replication $N^{*}$ to be able to produce output to the channel $x \in \mathcal{M}(\mathcal{I}, \: \mathcal{O})$, at least one box or a synchroniser in $N$ must have the output port wired to the complement channel $x'$. The \ak\ compiler recognizes the use of complement channels and checks whether the operand network topology has this property. If it does not, the compiler reports an error and aborts the compilation.

The \ak\ runtime is committed to support the dynamic rewiring for complement channels. The serial replication implementation depends on the \ak\ runtime implementation, particularly the primitives the runtime system provides for the network construction. We briefly describe two approaches to the serial replication implementation with respect to the available primitives.


The first approach relies on a port wiring primitive $P$ that transmits messages immediately from one port to another without storing them. The operand network $A$ in Fig. \ref{fig:ffp_new} has a single input port $x$ and two output ports. The output port $x$ is intended for the messages that proceed to the the next replica of $A$ in the chain, and the output port $x'$ is a complement port for the messages that are supposed to leave the replication pipeline. The serial replication network $A^{*}$ has a single input and a single output port both named $x$. During the compilation, the operand network $A$ is encapsulated into the special network $N$ it as shown in Fig. \ref{fig:ffp_new}. The network $N$ inherits all the ports from $A$ and adds a corresponding input port $x'$. The input and output ports $x'$ of $N$ are connected with the wiring primitive $P$. The output and the input ports $x'$ of the consequent replicas of $N$ are connected with the wiring primitive $P$ as well.
\begin{figure}[h!]
\centering
\includegraphics[scale=0.8]{figs/chapter_04_ffp_new.pdf}
\caption{The operand network $A$ (top) and a possible implementation of its serial replication $A^{*}$ (bottom)}
\label{fig:ffp_new}
\end{figure}
A message that $A$ sends to the output port $x'$ cascades through all the active replicas. Once it has reached an inactive replica, the output channel $x$ of $A^{*}$ is dynamically wired to the output port $x'$ of the last active replica of $N$. When the replica becomes active, the port $x'$ is rewired with the input port of this replica using $P$.

The second approach to the serial replication implementation relies on a merger with variable number of inputs. When a replica of $A$ sends a message to the output port $x'$, a new input channel is created for the merger $M$ and wired to the output port $x'$ of the replica as shown in Fig. \ref{fig:ffp_new_1}. The merger's output port is wired to the output channel $x$ of $A^{*}$.
\begin{figure}[h]
\centering
\includegraphics[scale=0.8]{figs/chapter_04_ffp_new_1.pdf}
\caption{Another possible implementation of the serial replication $A^{*}$}
\label{fig:ffp_new_1}
\end{figure}

%The serial replication implements a loop with variable tripcount



    \section{Reverse Fixed Point\label{rfp}}
% TODO: I don't like the reason. Why was the reverse fixed point introduced?
% reverse fixed point is the basic optimisation that preserves growth of the replicas chain.
As the chain of replicas evolves, it may be the case that some replicas in the head of the chain are active yet they just transmit messages without a change. \ak\ is commited to detect such replicas and optimise the connection so that the data are sent directly to a replica that is ready to process it. 

In this section we provide the approach to the reverse fixed point.

Consider a vertex $v$ that has an input and an output channel, both named $x$.

\begin{definition} The vertex $v$ is said to have a reverse fixed point in $x$ if and only if the following statements hold:

\begin{enumerate}
\item A unique non-branching path from the input to the output channel $x$ exists that does not traverse any boxes.

\item Every synchroniser $S_i$ on the path has a subset of states, which we denote as $s_i$, such that in each of these states every message on the path is immediately transferred without being changed or even stored, causing the synchroniser to remain in the same state\footnote{It should also be borne in mind that the values of any state variables form a part of the synchroniser state}. In a state from $s_i$ the synchroniser $S_i$ may still be sensitive to other input channels, as long as this does not, under any circumstances, cause a transition to a state outside $s_i$.
\end{enumerate}
\end{definition}

The vertex $v$ is said to be in a reverse fixed point state on channel $x$ when each $S_i$ is in a state that belongs to its $s_i$.

%%%%%%%%%
%%  Motivation for the reverse fixpoint
%%%%%%%%%
The reverse fix-point is defined to unify backslash \ combinatior and the star in terms of their functionality, which was never done in S-Net(TODO which patterns??). The intention is that they only differ in the pressure propagation strategy. The backslash creates no pressure (TODO why??) in its looped channel, and the start mantains and propagates the pressure in channels between instanses.

% probably a picture
%
% backslash (* is the synchroniser)
%      _________
%    \|/ _____  |
% ____*_|     |_|
%       |_____|
%
%
% Star with the reverse fix point
%        __________________
%      _|___________       |
%    _|______       |      |
%   |    __ \|/ __ \|/ __ \|/ __
% --*---|__|-*-|__|-*-|__|-*-|__|-- ...
%

The reverse fix point is more the way to write code. It is the way to program a loop dependency, when the result of the iteration depends not only on the result of the previous iteration but on the new incoming data. The difference with backslash is in the pressure propagation.

If you want the feature, you must define a closed set of translating states in every synchroniser on the fp path.


    \subsubsection{Rewiring of the Reverse FPS}
The reverse fixed point optimises an input connection that has to cascade through the chain to a replica that is ready to accept the data. Any input channel $x$ wired to an active replica $A_i$ that transitions to a reverse fixed point state on that channel is disconnected from $A_i$ and dynamically rewired to the input channel $x$ of the next replica on the chain $A'_{i+1}$.

%pic



%\section{Fixed Point Detection Algorithms}
%
%    \subsection{Forward Fixed Point Detection\label{ffp_detect}}
%The approch we proposed in section \ref{approach} makes the forward fixed-point detection trivial. The forward fixed-point detection does not require synchroniser analysis anymore. The \ak\ compiler just checks that the forward fixed-point exists in the network topology.
%
%We split the forward fixed-point detection problem into the following subproblems:
%\begin{itemize}
%\item Choose a data structure to represent a net
%\item Provide an algoritm for the fixed-point path detection
%\item Provide an algoritm for recursive fixed-point check
%\end{itemize}
%
%% Provide detection algorithm
%
%\ak\ compiler needs to just detect the forward fixpoint from the network topology (answer 'yes' or 'no' if the fixpoint exists). If the fixpoint was not found then the network is infinite and inconsistent.
%
%Forward fixpoint detection is pure network topology analysis. Find a way in a net graph that goes exclusively through mergers and some other vertex output to this channel.
%
%How to represent the net graph.
%We have (at least) 4 types of vertices: boxes, synchronisers, nets, mergers.
%If we find net on the way we have to run the analysis for it (recursively). For example:
% A net in wrapped in a Star combinator
%  __                               __
% |       _____________________       | *
% |      |    __      __       |      |
% |     _|  /|__|----|__|-\    |_     |
% |  a |_|-|      __      |----|_| a  |
% |      |  \----|__|-----/    |      |
% |     _|                |    |_     |
% |  b |_|---------------|N|---|_| b  |  - fix point channel b (goes straight throuhg the net)
% |      |               net   |      |
% |      |_____________________|      |
% |__                               __|
%
%We could represent the net graph as a multigraph (where a vertex, which is a box, a synch, a net or a merger can have several inputs and several outputs).
%But it is inconvenient because we cannot specify the connections to the net inputs and outputs. In order to specify this connections, we can have ports as vertices of a graph.

%We assume that the ports graph is a connected graph.

%We can filter the subgraph those vertices are only mergers and nets. In this case with the assumption of the original graph connectivity, the resulting graph is a connected graph by construction.
%We construct this graph by traversing all the vertices from the 'start' vertex (we have to keep it in the graph structure). We take the successors of the current vertex and check their 'type'. If the successor is a merger, we add it to the resulting graph and traverse it. (Anyway, generating such a graph seems useless since we can detect the paths we need with just a single traversal)
%
%Or we can leave the graph as is and just put a condition of every vertex we visit that it must be net or merger.


    \subsection{Reverse Fixed Point Detection\label{rfp_detect}}
%%% Synch state conditions for the reverse fixpoint state
A message is not changed by the synchroniser in some state when:
- message is sent out by the synchroniser without any changes and storing in any transition including user-specified $else$ ($this$)

A message sent in autogenerated $else$ transition is disregarded by the synchroniser.

If a message is sent out in a user-defined $else$ then we have to make sure that the message get to this $else$. Before $else$ the channel may be tested for variants and segmantation marks, so we have to make sure that the message doesn't contain these variants/not a segmentation mark whatever.
%%%%%%


Choose any convenient structure for nets to resolve fix points. It may be a kind of graph that traversing it it's easy to find paths that only consist of synchronisers.
It could be a hypergraph (each vertex may have several inputs and several outputs) with type vertices (something that indicates whether vertex is a synchroniser or a box)

This chosen structure can be build in the net parser of from the net compiler internal data structure.

Then we need to represent a set of possible paths in this hypergraph that only contain synchronisers. And a traversal of the hypergraph to find all these paths.

Then we analyse every synchroniser in each path for the satisfiability of fix point conditions.


    \subsection{Discussion}
%channels are ordered, need to insert synchronisers
Order of messages in the reverse fixed point may be changed, because a message may put the replica into the reverse fixed-point state and go for processing into this replica. In this case the messages that came to the replica that is in the reverse fixed-point state may overcome the message processed in the replica. This changes the order of messages. If the progrmmer wants to preserve the order, he must mind it. It may be fixed by creating a separate channel for RFP messages and putting a synchroniser that blockes the RFP channel while there's no message from the output channel (this is for operand network with one input channel, with two it can be more dificult if there're races between the channels that wire replicas).

The replication combinator is just a wiring pattern that does not have to guarantee race-safety. For example, if the operand network is not race-safe, the star is not race-safe as well.

