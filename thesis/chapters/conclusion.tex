\chapter{Conclusion}
    \section{Summary}
This thesis presented the implementation of \ak\ synchronisers and their role in the serial replication wiring pattern. It described 

Synchronisers are programmed in a dedicated language that is described in \cite{astrakahn}. We provide some minor syntax improvements and explain how each language construct should be used in a detailed guide. An \ak\ synchroniser has non-deterministic behaviour. We give an execution algorithm which defines the ordering of non-deterministic choices made by the synchroniser, and is a basis for the synchroniser runtime. We implement the language compiler that generates the data structure to be interpreted by the runtime, and the communication passport of the synchroniser. The compiler performs some semantic and type checking and reports errors in the source code as well.

In \ak\ the output from the serial replication pipeline is defined using the concept of fixed point. A fixed point is a message that is not changed after it has been processed by a newly created replica. In order to detect fixed point messages, \ak\ must be provided with a pattern that matches all of them. We show how this pattern can be embedded into the operand network of the serial replication combinator, so that the programmer does not have to specify it explicitly within the \ak\ application code. Since the original approach to the output from the serial replication is quite complicated, we provide a simple alternative. In order to suppress the growth of the replica chain, \ak\ introduces a reverse fixed point, which is a state of a replica that is known not to change an input connection anymore and thus can be optimised out. We give formal definitions of both kinds of fixed point and provide the algoritms for the \ak\ compiler to detect them.



    \section{Future Work}
In this chapter we have presented the language for \ak\ synchronisers. We have developed the language compiler that generates the CAL passport of the synchroniser. The message format in \ak\ is based on the Message Definition Language (MDL) with the restriction that data on streams are organised as collections of alternative records of label-value pairs. A value in a record can have any structure that is allowed by the MDL. The synchroniser that we have presented matches only a top-level structure of a message. The MDL generates a much broader set of terms than the current version synchroniser can synchronise; however, it needs to be elaborated whether the implementation of lower level synchronisation in synchronisers is useful for the real world applications.

The current version of the language does not define flow inheritance in synchronisers. The synchroniser \emph{code} only needs to access the label-value parts of the message it matches. Thus, the flow inheritance should be supported outside of the synchroniser definition and the question how it should be done is left open.

The compiler we have implemented does not optimise the code deeply. We have only implemented an elimination of unused states. However, a broader set of dead code elimination optimisations can be implemented\footnote{E.g. a conditional transition can be eliminated if its condition always evaluates to \emph{false}}.

Serial replication:
Implementation of the detection algorithms in the \ak\ compiler.

%explain about pressure propagation and statistics
The long-term goal of the \ak\ project is to provide an environment for development of scalable concurrent applications that do not require manual tuning efforts. Though the adaptive self-regulation mechanism is not known to propose something for synchronisers, we try to review the possible strategies for the pressure propagation through synchroniser.

